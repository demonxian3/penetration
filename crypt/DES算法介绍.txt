对称算法(symmetric algorithm)

  加密密钥能够从解密密钥中推算出来，同时解密密钥也可以从加密密钥中推算出来
  大多数的对称算法中，加密密钥和解密密钥是相同的，所以也称单密钥算法  
  要求发送方和接收方在安全通信之前，商定一个密钥
  对称算法的安全 性依赖于密钥
  泄漏密钥就意味着任何人都可以对他们发送或接收的消息解密
  
  优点：算法实现效率高 速度快
  缺点：密钥的管理过于复杂

      任何一对发送方和接收方都有各自商议的密钥的话，
    假设有N个用户进行对称加密通信，按上述方法，则要产生N(N-1)把密钥，
    每个用户要记住或保留N-1把密钥，当N很大时，记住是不可能的，而保留起来
    又会引起密钥泄漏可能性的增加

对称加密算法有DES，DEA


===============================================================================
===============================================================================
非对称加密(dissymmetrical encryption)

  用作加密的密钥不同于用作解密的密钥，而且解密密钥不能根据加密密钥计算出来
  又叫做公开密钥算法因为加密密钥可以公开，即陌生人可以得到它并用来加密信息
  但只有用相应的解密密钥才能解密信息。在这种加密算法中，
  加密密钥被叫做公开密钥(public key)，而解密密钥被叫做私有密钥(private key)

  缺点：算法实现效率低，速度慢
  优点：密钥管理简单
  
    非对称加密的优点在于用户不必记忆大量的提前商定好的密钥
    因为发送方和接收方事先根本不必商定密钥
    发放方只要可以得到可靠的接收方的公开密钥就可以给他发送信息了
    而且即使双方根本互不相识。但为了保证可靠性，
    非对称加密算法需要一种与之相配合使用的公开密钥管理机制，
    这种公开密钥管理机制还要解决其他一些公开密钥所带来的问题。
 
非对称加密算法有RSA
  
  总结：公钥加密的数据只有私钥能解 用于数据加密
        私钥加密的数据只有公钥能解 用于数据签名



===============================================================================
===============================================================================
DES算法（Data Encryption Standard）
 
  是一种典型的传统密码体制，利用传统的换位和置换等加密方法，是目前最为常用的分组密码系统
  由IBM公司研制的一种加密算法，美国国家标准局于1977年公布把它作为非机要部门使用的数据加密标准
  一直活跃在国际保密通信的舞台上，扮演了十分重要的角色

  是一个分组加密算法，以64位为分组对数据加密，加密和解密用的是同一个算法 
  密匙长度是56位，每个第8 位都用作奇偶校验 

  算法框架
    对64(bit)位的明文分组M进行操作
    M经过一个初始置换IP置换成m0
    将m0明文分成左半部分和右半部分m0=(L0，R0)
    各32位 长。然后进行16轮完全相同的运算
    这些运算被称为函数f，在运算过程中数据与密匙结合
    经过16轮后，左，右半部分合在一起经过一个末置换，完成

    在每一轮中，密匙位移位，然后再从密匙的56位中选出48位
    通过一个扩展置换将数据的右半部分扩展成48位    
    并通过一个异或操作替代成新的32位数据
    在将其置换换一次。这四步运算构成了函数f
    然后，通过另一个异或运算，函数f的输出与左半部分结合
    其结果成为新的右半部分，原来的右半部分成为新的左半部分
    将该操作重复16次，就实现了

    加密和解密使用相同的算法，唯一的不同是密匙的次序相反
    如各轮加密密匙是 K0，K1，K2，K3 … K15
    则各轮解密密匙是 K15，K14，K13  … K0。

  几种工作方式
    第一种电子密本方式（ECB）
      将明文分成n个64比特分组，如果明文长度不是64比特的倍数
      则在明文末尾填充适当数目的规定符号。对明文组用给定的密钥
      分别进行加密，行密文C=(C0，C1，……，Cn-1)
      其中Ci=DES(K，xi)，i=0，1，…。。，n-1。

    第二种密文分组链接方式（CBC）
      在CBC方式下，每个明文组xi在加密前与先一组密文按位模二加后
      再送到DES加密，CBC方式克服了ECB方式报内组重的缺点
      但由于明文组加密前与一组密文有关，因此前一组密文的错误会传播到下一组。

    第三种密文反馈方式（CFB），可用于序列密码
      明文X＝(x0，x1，……，xn-1)，其中xi由t个比特组成0

    第四种输出反馈方式（OFB），可用于序列密码
      与CFB唯一不同的是OFB是直接取DES输出的t个比特
      而不是取密文的t个比特，其余都与CFB相同
      但它取的是DES的输出，所以它克服了CFB的密文错误传播的缺点


===============================================================================
===============================================================================
DES算法流程图
    DES算法把64位的明文输入块变为64位的密文输出块
    它所使用的密钥也是64位，整个算法的主流程图如下：
    
    功能：把输入的64位数据块按位重新组合，。
          并把输出分为L0、R0两部分
          每部分各长32位，其置换规则见下表：。

    58，50，12，34，26，18，10，2，60，52，44，36，28，20，12，4， 
    62，54，46，38，30，22，14，6，64，56，48，40，32，24，16，8， 
    57，49，41，33，25，17， 9，1，59，51，43，35，27，19，11，3， 
    61，53，45，37，29，21，13，5，63，55，47，39，31，23，15，7，

    上表表示：将输入的第58位换到第一位，第50位换到第2位，依此类推
    最后一位是原来的第7位，L0、R0则是换位输出后的两部分
    L0是输出的左32 位，R0 是右32位

    比如：置换前的输入值为D1 D2 D3 ... D64
    则经过初始置换后的结果为：
    L0 = D58 D50 ... D8
    R0 = D57 D49 ... D7

    经过16次迭代运算后。得到L16、R16
    将此作为输入，进行逆置换，即得到密文输出
    逆置换正好是初始置的逆运算
    如，第1位经过初始置换后，处于第40位
    而通过逆置换，又将第40位换回到第1位
    其逆置换规则如下表所示：

    40，8，48，16，56，24，64，32，39，7，47，15，55，23，63，31， 
    38，6，46，14，54，22，62，30，37，5，45，13，53，21，61，29， 
    36，4，44，12，52，20，60，28，35，3，43，11，51，19，59，27， 
    34，2，42，10，50，18，58，26，33，1，41， 9，49，17，57，25，

    放大换位表 
    32，1， 2， 3， 4， 5， 4， 5， 6， 7， 8， 9， 8， 9， 10，11， 
    12，13，12，13，14，15，16，17，16，17，18，19，20，21，20，21， 
    22，23，24，25，24，25，26，27，28，29，28，29，30，31，32， 1，

    单纯换位表 
    16，7，20，21，29，12，28，17， 1，15，23，26， 5，18，31，10， 
     2，8，24，14，32，27， 3， 9，19，13，30， 6，22，11， 4，25，

    在f(Ri，Ki)算法描述图中：S1，S2。。。S8为选择函数
    其功能是把6bit数据变为4bit数据
    下面给出选择函数Si(i=1，2。。。。。。8)的功能表：
    选择函数Si 

	S1:
	14，4，13，1，2，15，11，8，3，10，6，12，5，9，0，7， 
	0，15，7，4，14，2，13，1，10，6，12，11，9，5，3，8， 
	4，1，14，8，13，6，2，11，15，12，9，7，3，10，5，0， 
	15，12，8，2，4，9，1，7，5，11，3，14，10，0，6，13， 

	S2: 
	15，1，8，14，6，11，3，4，9，7，2，13，12，0，5，10， 
	3，13，4，7，15，2，8，14，12，0，1，10，6，9，11，5， 
	0，14，7，11，10，4，13，1，5，8，12，6，9，3，2，15， 
	13，8，10，1，3，15，4，2，11，6，7，12，0，5，14，9， 

	S3: 
	10，0，9，14，6，3，15，5，1，13，12，7，11，4，2，8， 
	13，7，0，9，3，4，6，10，2，8，5，14，12，11，15，1， 
	13，6，4，9，8，15，3，0，11，1，2，12，5，10，14，7， 
	1，10，13，0，6，9，8，7，4，15，14，3，11，5，2，12， 

	S4: 
	7，13，14，3，0，6，9，10，1，2，8，5，11，12，4，15， 
	13，8，11，5，6，15，0，3，4，7，2，12，1，10，14，9， 
	10，6，9，0，12，11，7，13，15，1，3，14，5，2，8，4， 
	3，15，0，6，10，1，13，8，9，4，5，11，12，7，2，14， 

	S5: 
	2，12，4，1，7，10，11，6，8，5，3，15，13，0，14，9， 
	14，11，2，12，4，7，13，1，5，0，15，10，3，9，8，6， 
	4，2，1，11，10，13，7，8，15，9，12，5，6，3，0，14， 
	11，8，12，7，1，14，2，13，6，15，0，9，10，4，5，3， 
	
	S6: 
	12，1，10，15，9，2，6，8，0，13，3，4，14，7，5，11， 
	10，15，4，2，7，12，9，5，6，1，13，14，0，11，3，8， 
	9，14，15，5，2，8，12，3，7，0，4，10，1，13，11，6， 
	4，3，2，12，9，5，15，10，11，14，1，7，6，0，8，13， 

	S7: 
	4，11，2，14，15，0，8，13，3，12，9，7，5，10，6，1， 
	13，0，11，7，4，9，1，10，14，3，5，12，2，15，8，6， 
	1，4，11，13，12，3，7，14，10，15，6，8，0，5，9，2， 
	6，11，13，8，1，4，10，7，9，5，0，15，14，2，3，12，
 

	S8: 
	13，2，8，4，6，15，11，1，10，9，3，14，5，0，12，7， 
	1，15，13，8，10，3，7，4，12，5，6，11，0，14，9，2， 
	7，11，4，1，9，12，14，2，0，6，10，13，15，3，5，8， 
	2，1，14，7，4，10，8，13，15，12，9，0，3，5，6，11， 

    在此以S1为例说明其功能，我们可以看到：
    在S1中，共有4行数据，命名为0，1、2、3行
    每行有16列，命名为0、1、2、3，。。。。。。，14、15列
    设输入为： D ＝D1D2D3D4D5D6
    令：       列＝D2D3D4D5 
               行＝D1D6

    在S1表中查得对应的数，以4位二进制表示，此即为选择函数S1的输出
    下面给出子密钥Ki(48bit)的生成算法 

    从子密钥Ki的生成算法描述图中我们可以看到：初始Key值为64位，
    但DES算法规定，其中第8 16 ... 64位是奇偶校验位不参与DES 运算
    实际可用位数便只有56位，即：经过缩小选择换位表1的变换后
    Key 的位数由64 位变成了56位，此56位分为C0、D0两部分，各28位
    然后分别进行第1次循环左移，得到C1、D1
    将C1（28位）和 D1（28位）合并得到56位
    再经过缩小选择换位2,从而便得到了密钥K0（48位）
    依此类推，便可得到K1 K2 ... K15
    需要注意的是，16次循环左移对 应的左移位数要依据下述规则进行：
    循环左移位数 
    1，1，2，2，2，2，2，2，1，2，2，2，2，2，2，1 

    以上介绍了DES算法的加密过程。DES算法的解密过程是一样的，
    区别仅仅在于第一次迭代时用子密钥K15，第二次K14 ... 最后一次用K0
    算法本身并没有任何变化。

    

===============================================================================
===============================================================================
实现代码
http://blog.csdn.net/zidane_2014/article/details/37988657



    